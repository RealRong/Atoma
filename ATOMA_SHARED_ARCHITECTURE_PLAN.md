# Atoma Shared Architecture Plan (No-Compatibility, One-Step Target)

## 1. Background and Goal

Current issues:
- Cross-package runtime helpers are duplicated (`randomUUID` fallback, `Date.now + Math.random` id builders, error normalization, URL helpers).
- `atoma-core/src/store` mixes pure mutation logic with runtime strategy defaults (default id generation + current-time policy).
- Entity ID and operation context ID are generated by different implementations, increasing divergence risk.

Target:
- Use `atoma-shared` as the single runtime utility foundation.
- Keep `atoma-core` pure (domain transform only, no default runtime policy decisions).
- Keep naming short and semantic.
- No compatibility layer, direct convergence.

---

## 2. Package Boundary Design

### 2.1 `atoma-types/shared`
Type-only scalar contracts.
- Keep: `EntityId`, `Version`, `Cursor`, `CursorToken`
- Forbidden: runtime helper functions, random/crypto, URL/error logic

### 2.2 `atoma-shared`
Runtime shared foundation across packages.
Owns:
- ID/random primitives
- clock/time helpers
- error normalization
- stable serialization
- URL helpers
- optional zod helpers

### 2.3 `atoma-core`
Pure domain transforms only.
- `store`: init/merge/writeback/map operations
- `operation`: context shaping only (delegates id generation to shared)
- Forbidden: default ID policy embedded in core

### 2.4 `atoma-runtime/client/plugins/server`
May depend on `atoma-shared` for runtime utilities.
Must not re-implement random fallback logic.

---

## 3. ID Strategy (Unified)

## 3.1 Default strategy decision
- Default entity ID SHOULD NOT be current snowflake implementation.
- Default should be UUIDv7-style sortable ID (or equivalent time-ordered ID) from one shared primitive.
- Snowflake remains optional, explicit opt-in strategy only.

Rationale:
- Current snowflake variant has no machine/worker partitioning; cross-client collision risk remains.
- Busy-wait sequence overflow path is undesirable in browser/node mixed runtime.
- UUIDv7-style IDs provide better global uniqueness and good ordering behavior.

## 3.2 Shared ID API (proposed, minimal surface)
In `atoma-shared/src/id.ts` (new), expose one primary API:
- `createId(args?: { kind?: 'action' | 'entity' | 'request' | 'replica'; sortable?: boolean; prefix?: string; now?: () => number }): string`

Optional thin aliases (high-frequency only):
- `createEntityId()`
- `createActionId()`

Internal-only (not exported):
- random UUID probing/fallback helpers
- low-level random/sortable builders

Notes:
- All packages must call shared APIs, no direct `Math.random` fallback in package-local code.
- Prefixes remain semantic and short, but should be controlled by `createId` strategy defaults.
- Avoid over-exposing many near-duplicate APIs; keep one canonical entry.

## 3.3 Protocol tools integration
`atoma-types/protocol-tools/ids.ts` should delegate to shared `createId` (or thin aliases), not maintain an independent random implementation.

---

## 4. `atoma-core/src/store` Optimization

## 4.1 Current problems
- `initBaseObject` currently embeds default generator selection and current-time policy.
- `store/index.ts` exports `defaultSnowflakeGenerator`, coupling core to policy.

## 4.2 Target model
Core store APIs become policy-free pure functions.
- `initEntity` (or keep `initBaseObject` name) receives required runtime inputs via args:
  - `idGenerator` (required unless id already provided)
  - `now` (required or injected by caller)
- `mergeForUpdate` receives `now` as arg.
- `bulkAdd`, `bulkRemove`, `preserveReferenceShallow`, `applyWritebackToMap` remain pure.

Runtime decides defaults:
- `schema.idGenerator` > `runtime.defaults.idGenerator` > shared default (`createId({ kind: 'entity', sortable: true })`).

---

## 5. `operation` and Context Creation Optimization

`createOperationContext` stays as the single context shaper but must delegate ID generation to shared ID utilities.
- Keep in core for domain semantics (`scope/origin/label/timestamp` shaping).
- Remove local crypto fallback logic from core operation module.

---

## 6. File-level Migration Plan

Phase A: Shared foundation first
1. Add `packages/atoma-shared/src/id.ts`
2. Export from `packages/atoma-shared/src/index.ts`
3. Replace local random fallbacks in:
   - `packages/atoma-core/src/operation.ts`
   - `packages/atoma-server/src/runtime/createRuntime.ts`
   - `packages/plugins/atoma-sync/src/internal/replica-id.ts`
   - `packages/plugins/atoma-sync/src/policies/single-instance-lock.ts`
   - `packages/plugins/atoma-observability/src/trace/fns.ts`

Phase B: Protocol tools convergence
4. Refactor `packages/atoma-types/src/protocol-tools/ids.ts` to delegate to shared id primitives.

Phase C: Core store purification
5. Refactor `packages/atoma-core/src/store/write/utils.ts`:
   - remove embedded default snowflake fallback
   - inject `now/idGenerator`
6. Remove `defaultSnowflakeGenerator` from `packages/atoma-core/src/store/index.ts` export surface.
7. Keep snowflake implementation as optional utility only (non-default path).

Phase D: Runtime wiring
8. Wire shared default entity id strategy in runtime/store factory.

---

## 7. Validation Checklist

- No `Math.random`-based ID fallback outside shared ID module.
- No package-local direct `crypto.randomUUID` fallback duplication.
- `atoma-core/store` has no default runtime policy decisions.
- Entity ID default is no longer snowflake.
- `pnpm typecheck` passes across workspace.

---

## 8. Naming and API Rules for This Refactor

- Class-led files: PascalCase.
- Function/type-led files: camelCase.
- API names short and semantic (`createId`, `createEntityId`, `createActionId`).
- Avoid redundant suffixes (`*Engine`, `*Utils`) unless semantically necessary.
