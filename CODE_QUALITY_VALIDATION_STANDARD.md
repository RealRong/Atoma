# Atoma 代码校验标准（架构 / 性能 / 命名 / 降噪）

> 目标：作为 AI 与人工统一执行的“仓库校验与优化基线”。
> 适用范围：`atoma-core`、`atoma-runtime`、`atoma-client`、`atoma-types`、`plugins/*`。
> 决策前提：当前阶段以**一步到位最优架构**为目标，**不以兼容旧接口为约束**（无外部用户包袱）。

---

## 1. 总体目标

1. **架构清晰**：职责单一、边界明确、依赖方向稳定。
2. **API 极简**：减少无效能力与噪音暴露，默认收敛到最小公开面。
3. **性能可预期**：查询/写入/索引路径避免重复扫描与重复计算。
4. **命名一致**：短命名、强语义、统一风格，降低认知成本。
5. **可持续演进**：后续优化可在不引入新混乱的前提下继续推进。

---

## 2. 架构校验标准（必须满足）

### 2.1 职责分离

- `Runtime` 只做系统装配与流程编排，不承载大块细节实现。
- 调试、索引、关系、查询、写入策略等能力应拆到独立模块/类。
- UI/Devtools 不反向污染核心读写路径。

### 2.2 单一主入口

- 同一语义只保留一个“主入口”，其余仅允许薄包装。
- 不允许并行主入口长期共存（如本地查询多套主路径）。
- 包内入口以“语义域入口”组织，避免重复中转层。

### 2.3 能力注册统一

- 跨插件能力通过 `CapabilitiesRegistry` 统一注册/读取。
- 禁止新增并行 registry（如“再造一套 debug registry”）。
- 仅保留 capability 常量与协议类型；helper 可收敛时优先收敛。

### 2.4 去兼容层原则

- 无真实用户依赖时，允许直接移除旧路径/旧别名/旧包装。
- 迁移目标是最终形态，不做长期“双轨并存”。

### 2.5 依赖方向

- `types` 只定义协议与类型，不承载实现逻辑。
- `core` 负责纯内核能力，`runtime` 负责编排执行，`client` 负责装配与入口体验。
- 插件依赖核心协议，避免把插件细节反向塞入核心。

---

## 3. API 设计与对外暴露标准（必须满足）

### 3.1 默认最小公开面

- 默认不暴露；只有被明确消费的能力才导出。
- 删除未生效、无消费者、仅“看起来有用”的选项/API。
- 对外接口优先 `named export`，避免 namespace 大对象导出。

### 3.2 禁止噪音暴露

- 禁止 `import * as Types from ...` 这类弱约束风格。
- 禁止仅为“语法好看”而增加无价值转发层。
- 不保留“只用于未来可能性”的开放参数。

### 3.3 子入口优先

- 优先子入口（subpath exports）而非超大根聚合导出。
- 根 `index.ts` 不应成为“全部模块再导出垃圾桶”。

---

## 4. 命名与文件结构标准（必须满足）

### 4.1 命名

- `class` 使用 **PascalCase**。
- `class` 所在文件名使用 **PascalCase**（与类名一致优先）。
- 非 class 文件使用短语义命名，避免冗余后缀（如重复 `Engine` 尾巴）。
- 函数/变量使用 `camelCase`，常量使用 `UPPER_SNAKE_CASE`。

### 4.2 API 命名

- API 名称要短、动词明确、行业通用（如 `build`、`plan`、`query`、`apply`）。
- 避免“解释型长命名 + 重复上下文”。
- 同域术语统一，禁止同义词混用（如 run/query/execute 混乱并存）。

### 4.3 目录结构

- 同一域内按“能力分组”，避免 `utils/` 黑洞。
- 根目录保留高价值入口文件；细节实现下沉到域目录。
- 禁止出现“层级很多但每层只有转发”的空心结构。

---

## 5. 性能校验标准（必须满足）

### 5.1 查询与索引

- 可走索引时优先索引，不回退全量扫描。
- 同一查询流程不得重复做等价计算。
- 索引计划与候选集计算集中在单路径，避免分叉实现。

### 5.2 写入与变更追踪

- `changedIds` 等变更信息应集中在提交路径统一处理。
- 禁止在多层重复收集/重复合并同类状态。
- 能在 commit 边界统一收敛的逻辑，不散落在各流程。

### 5.3 时间与 ID

- 核心路径禁止直接 `Date.now()`，优先注入 `now()`。
- ID 生成策略统一来源，避免多包重复实现。
- 无业务差异时不保留过多同类 ID API。

### 5.4 调试快照

- Debug snapshot 必须轻量，避免高频重型序列化。
- 采样字段有上限（如 sample 截断），避免全量复制大对象。

---

## 6. 可维护性与可读性标准（必须满足）

1. 一个文件只表达一个清晰主题。
2. 函数长度与嵌套深度受控，超阈值即拆分。
3. 无死代码、无死参数、无“未来占位”注释逻辑。
4. 注释只解释“为什么”，不重复“代码在做什么”。
5. 复用要抽“稳定语义”，不要抽“偶然相似代码”。

---

## 7. 校验清单（执行顺序）

## P0（必做，阻断合并）

- 架构边界是否清晰，是否存在职责串层。
- 是否存在重复主入口/双轨流程。
- 是否新增了无消费者 API 或无效配置项。
- 是否引入明显性能回退（全表扫描、重复计算、重复序列化）。
- 是否破坏命名与目录规范。

## P1（强烈建议）

- 是否还能进一步收窄公开 API。
- 是否还有可内聚的薄包装/中转文件。
- 是否存在可提炼但未复用的稳定逻辑。
- 是否可减少类型噪音与泛型噪音。

## P2（持续优化）

- 可观测性字段是否结构统一。
- Devtools/debug 输出是否更利于渲染消费。
- 是否可进一步降低模块耦合。

---

## 8. 常见反模式（发现即整改）

- 多个“看似等价”的入口函数长期并存。
- 仅为兼容历史而保留且无人使用的 API。
- `import * as Xxx` 聚合型导入导致类型边界模糊。
- `utils.ts` 无限膨胀，语义不分层。
- 配置项声明存在但执行路径不消费。
- 调试元信息写了但不参与任何行为与显示决策。

---

## 9. 校验命令基线

按变更包最小化执行：

- `pnpm --filter <pkg> typecheck`
- `pnpm --filter <pkg> build`

跨包改动或边界调整后，执行：

- `pnpm typecheck`

如涉及行为逻辑，补充：

- `pnpm test` 或对应包测试命令

---

## 10. AI 执行准则（用于自动优化）

1. 先做“结构正确”，再做“代码好看”。
2. 优先删减噪音，再考虑新增抽象。
3. 每次优化必须回答三个问题：
   - 这个能力是否真的被使用？
   - 这个能力是否放在正确层？
   - 这个命名是否最短且语义最清晰？
4. 若无法同时满足“低耦合 + 低噪音”，优先保证职责边界正确。
5. 不做无收益重构；每次变更都应能指出明确收益（复杂度、性能或认知负担下降）。

---

## 11. 验收标准（完成定义）

当一次优化满足以下条件，视为完成：

- 类型检查通过（至少受影响包通过）。
- 构建通过（至少受影响包通过）。
- 无新增死 API / 死参数 / 死路径。
- 对外 API 面未膨胀，或已收敛。
- 文档/命名/目录与本标准一致。

