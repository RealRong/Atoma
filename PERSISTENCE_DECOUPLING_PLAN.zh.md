# 持久化解耦方案（服务端版本权威 + 本地内生版本）

本方案目标：将“本地内存状态（jotai + indexes）”与“持久化/外部副作用”彻底解耦，同时保持 **服务端版本权威**，并在纯本地/离线阶段维持可用的版本语义（不引入双版本字段）。

## 核心结论
- **本地内存状态是事实状态（source of truth for UI）**，独立于持久化。
- **持久化是可选副作用**（可以不存在、可延迟、可失败）。
- **服务端版本权威**：一旦连上服务端，`version` 必须以服务端返回为准。
- **本地内生版本**：仅用于纯本地/离线阶段维持写入链路，不引入双版本字段。

## 设计原则
1. **单向流**：先更新本地状态，再触发持久化（若存在）。
2. **本地版本只在离线有效**：线上成功写入后，服务端版本覆盖本地版本。
3. **持久化不改内存**：持久化只产出“外部回执”，不驱动内存写回。
4. **插件边界清晰**：writeStrategy 只处理副作用，不触碰本地状态。

## 概念划分

### 1) Local State Layer（本地内存层）
职责：
- 生成 optimistic state。
- 维护 jotai map + indexes。
- **离线阶段**生成版本：create=1，update/delete/upsert 递增，严格校验 baseVersion。

### 2) Persistence Layer（持久化副作用层）
职责：
- 执行外部副作用（HTTP / IndexedDB / SQLite / queue）。
- 返回“是否确认/失败”与服务端回执（serverVersion / data）。
- **不负责修改本地内存状态**。

## 行为模型（两种运行模式）

### A) 纯本地 / 离线模式
1. 本地内存更新（optimistic + patches）。
2. **本地内生版本更新**（保证 baseVersion 链条不断）。
3. 不触发持久化（或持久化为空实现）。
4. 本地状态即结果。

### B) 在线（接入 atoma-server）
1. 本地内存先更新（optimistic）。
2. 触发持久化副作用（HTTP write）。
3. 服务端返回 `serverVersion`（及可能完整 data）。
4. **用服务端版本覆盖本地版本**（若有 data 则用 data 覆盖本地对象）。

> 核心规则：**线上成功写入后，服务端版本覆盖本地版本**。本地版本不再作为权威。

## 服务端回执包含 data 时的写回规则（必须明确）

当服务端回执包含 `data`（完整对象或部分字段）时，客户端按以下规则写回：

1. **优先级**
   - `data` 为权威快照，优先于本地 optimistic 结果。
   - `data.version`（或 serverVersion）必须覆盖本地 `version`。

2. **写回方式**
   - 推荐 **整对象覆盖**（以服务端 `data` 为准）：
     - 使用服务端 `data` 替换本地同 id 的对象。
     - 以 `data` 驱动 indexes 更新。
   - 如服务端仅返回部分字段（sparse data），则必须显式声明该 data 是否可写入缓存：
     - 若不保证完整性，则 **禁止写回**（避免污染本地缓存）。
     - 若保证完整性，则按整对象覆盖。

3. **无 data 时**
   - 仅用 `serverVersion` 覆盖本地版本；其他字段保持本地结果。

> 推荐做法：服务端返回完整对象（含 version），客户端统一按“整对象覆盖”处理，逻辑最简单且一致。

## 与 atoma-server 的一致性
- atoma-server **严格依赖 baseVersion**（update/delete 必填；upsert strict 需要 baseVersion）。
- 因此：
  - 离线阶段生成的本地 version 只用于本地链路。
  - 在线时，必须以服务端返回的 serverVersion 为准，保持一致。

## 现状 vs 修改后（表现对比）

### 1) 写入与内存更新
- **现状**：
  - 本地 optimistic 更新 → persistence → writeback 再回写版本/created。
  - 持久化结果参与内存最终状态。
- **修改后**：
  - 本地更新独立完成；持久化只作为副作用。
  - 服务端回执仅用于覆盖 version / data（不再作为“写回主路径”）。

### 2) 版本语义
- **现状**：
  - 版本多依赖服务端 writeback。
  - 本地模式需要模拟或绕行。
- **修改后**：
  - 离线阶段本地生成版本。
  - 在线成功后服务端版本覆盖本地版本（权威）。

### 3) 本地模式
- **现状**：
  - 依赖模拟 backend 或 persistence 变体。
- **修改后**：
  - 完全纯本地运行，不触发持久化。

### 4) 插件职责
- **现状**：
  - 插件可能影响内存写回流程。
- **修改后**：
  - 插件只负责副作用（队列/持久化），不触碰内存写回。

## 分阶段实施方案（破坏式）

> **注意：这是破坏式更新，不做兼容（没有用户）。**

### 阶段 1：链路拆分（最小可运行）
- 在 mutation 层把“本地内存更新”从 persistence writeback 中解耦。
- persistence 仍执行，但其返回值不再驱动内存写回。
- 服务端回执仅用于覆盖版本（若有）。

### 阶段 2：版本内生化（离线场景）
- 将版本生成前置到本地 mutation 阶段。
- local-only 模式不触发任何持久化，也能完整执行版本链。

### 阶段 3：持久化语义简化
- `PersistResult` 仅保留 status/ack/error，移除 writeback。
- 清理 writeback collector 的核心依赖，保留必要的 server ack 解析。

### 阶段 4：插件边界收敛
- writeStrategy 插件只处理副作用，不再介入内存写回。
- 文档与示例同步更新。

## 风险与取舍
- 离线写入上线后可能冲突，需要上层处理重试/提示。
- 没有双版本字段，简单但牺牲“同时保留本地/服务端版本”的可观测性。

## 结论
该方案保持持久化解耦，同时坚持“服务端版本权威”。本地版本只服务于离线链路，不引入双版本字段，复杂度最低且与 atoma-server 语义兼容。
