## CODE_SIMPLIFIER

### 一、简化检查项（基础）

1. 函数是否需要拆分，或在单次使用场景内联以提升可读性与简洁度。
2. 传参是否能减少，或整合成更内聚的 `context`（避免过度设计）。
3. 在功能不变前提下，流程是否可以减少步骤、降低分支复杂度。
4. 文件名、变量名、函数名、类型名是否过长或语义不清；优先更简短、更常见、易理解的词（尽量 1-2 个词，但不牺牲可读性）。
5. 是否存在冗余代码或逻辑；若有 2 处及以上相同且语义稳定的逻辑，考虑抽取公共函数，并确认其放置层级合理。

### 二、简化检查项（进阶）

1. 控制流简化：是否可用早返回、卫语句减少嵌套层级。
2. 条件表达式简化：布尔逻辑是否可去重、去双重否定、提炼为可读谓词。
3. 状态管理简化：是否能减少可变状态，消除跨步骤临时状态。
4. 数据流简化：同一数据是否被重复转换或拷贝，能否合并为单一流水线。
5. API 面简化：函数或模块是否职责过多，能否拆为语义单一的接口。
6. 异步流程简化：是否存在多余 `async/await`、可并行却串行的流程、过深回调层级。
7. 错误路径简化：重复 `try/catch` 或重复错误映射是否可集中处理。
8. 集合操作简化：同一集合多次遍历是否可合并，链式调用是否过长。
9. 计算路径简化：可复用结果是否被重复计算，是否可合理缓存。
10. 模块边界简化：是否存在仅透传参数的“空包装层”可去除。
11. 依赖关系简化：未使用依赖、重复工具函数、同功能多库并存是否可收敛。
12. 类型表达简化：冗余泛型、过深类型嵌套、重复类型别名是否可降复杂度。
13. 配置模型简化：配置项是否重复、冲突或语义重叠，能否收敛成更清晰模型。
14. 测试代码简化：重复 fixture、样板断言、重复 mock 是否可抽象为测试辅助工具。
15. 命名族目录化（prefix-based operation family modularization）：当同层实现共享稳定前缀且仅在操作语义上分化，应将公共前缀上提为目录边界，并将文件名收敛，以消除命名冗余并强化语义索引。

### 三、触发阈值（建议）

1. 函数长度大于 60 行，触发“拆分评估”。
2. 嵌套深度大于 3 层，触发“控制流简化评估”。
3. 分支数量大于 5，触发“条件重构评估”。
4. 参数数量大于 4，触发“参数收敛评估”。
5. 同类逻辑重复达到 2 处及以上，触发“抽象评估”。
6. 同一数据集合遍历达到 3 次及以上，触发“遍历合并评估”。
7. 链式调用超过 3 段，触发“可读性与可调试性评估”。
8. 同类错误处理重复达到 2 处及以上，触发“错误路径收敛评估”。

### 四、强约束（用于 AI 代码检查）

1. 正确性优先：任何简化不得改变对外行为（输入输出、异常语义、副作用、执行时序）。
2. 架构边界优先：不得跨层引入反向依赖；不得引入兼容别名、双路径或过渡导出。
3. 可读性优先于“更短”：禁止为缩短代码而牺牲语义表达。
4. 抽象有门槛：仅在语义稳定、命名清晰且存在真实复用时抽象，避免“工具函数泛滥”。
5. 错误处理不退化：禁止吞错；错误信息应保留必要上下文，便于定位。
6. 性能不退化：避免因重构引入不必要循环、对象分配、异步封装或重复计算。
7. 变更可验证：每条建议需给出最小验证方式（受影响测试、类型检查或关键路径回归点）。
8. 输出可审计：每条建议按“问题 -> 修改 -> 收益 -> 风险 -> 验证”结构输出。

### 五、建议输出格式（AI）

- 问题：
- 修改建议：
- 收益：
- 风险：
- 验证方式：
